Algorithms 4th Ed

Exercises 1

1.1.1 Give the value of the following expressions:

a) (0 + 15) / 2 ?

= 7

because is integer division.  15/2 = 7.5 gets truncated to 7

b) 2.0e-6 * 100000000.1

== 0.000002 * 100000000.1

= 2 x 10^-6 * 1000000001 * 10^-1 == 2000000002 * 10^-7 == 200.0000002

Program prints this value as expected

c) true && false || true && true

evaluation is left associative so first term is true then next term is false BUT there is then an or so 
checks that term - is true so then checks last term - is true so returns true.

1.1.2 Give the type and value of each of the following expressions:

a) (1 + 2.236) / 2

In brackets there is a floating point number so integer 1 is promoted to floating point and hence brackets 
evaluates to 3.236.  floating point divided by integer is promoted to floating point division and result is: 1.618

b) 1 + 2 + 3 + 4.0 = 10.0

addition is left associative so 1 + 2 + 3 results in integer addition resulting in 6

Then you get 6 + 4.0 which is promoted to 6.0 + 4.0 = 10

c) 4.1 >= 4  = true

d) 1 + 2 + "3" = "123"

*** Got that wrong.  I am getting 33.  Why???

Ah got it, addition is left associative so you get 1+2 = 3 by integer addition. Then java seens + used 
with an integer and a string so the tostring conversion is used to concatenate resulting in "33"

1.1.3 Write a program that takes three integer command line arguments and prints equal if all three are equal, 
and not equal otherwise.

// set PATH="C:\Program Files\Java\jdk1.7.0_07\bin";%PATH%
// javac -cp stdlib.jar;algs4.jar;. ex1a.java
// java -cp stdlib.jar;algs4.jar;. ex1a 6 7 8

public class ex1a {

  public static void main(String[] args) {
      if(args.length < 3)
	  StdOut.println("Must pass 3 integer arguments");
      else {
         int n1 = Integer.parseInt(args[0]);
         int n2 = Integer.parseInt(args[1]);
         int n3 = Integer.parseInt(args[2]);
         StdOut.println( n1 == n2 && n2 == n3 ? "equal" : "not equal");
      }
  }
}

1.1.4 What (if anything) is wrong with each of the following statements?

a) if (a > b) then c = 0;  // then is a syntax error
b) if a > b { c = 0; }     //brackets around a>b expression required
c) if (a > b) c = 0;       // fine.
d) if (a > b) c = 0 else b = 0;   //; required after c = 0

1.1.5 Write a code fragment that prints true if the double variables x and y are both strictly between 
0 and 1 and false otherwise.

  public static void main(String[] args) {
      if(args.length < 2)
	  StdOut.println("Must pass 2 double arguments");
      else {
         double d1 = Double.parseDouble(args[0]);
         double d2 = Double.parseDouble(args[1]);
         StdOut.println(d1 > 0 && d1 < 1 &&  d2 > 0 && d2 < 1 );
      }
  }

 
 1.1.16 Give the value of exR1(6):

    public static String exR1(int n)
    {
        if (n >= 0) return "";
        return exR1(n-3) + n + exR1(n-2) + n;
    }

   exR1(6) -> n >= 0 so returns blank string    
      
1.1.17 Criticise the following recursive function:

    public static String exR2(int n)
    {
        String  s = exR2(n-3) + n + exR2(n-2) + n;
        if(n <= 0) return "";
        return s;
    }

   Example exR2(6)

   exR2(6) -> exR2(3) + 6 + exR2(4) + 6;

   exR2(3) -> exR2(0) + 3 + exR2(1) + 3;

   exR2(4) -> exR2(1) + 4 + exR2(2) + 4;

   exR2(0) -> exR2(-3) + 0 + exR2(-2) + 0;

   Problem is that the base case (ie when a condition met, return) is AFTER recursive calls.  So recursion 
   step never ends.  Get stackoverflow as per book.


1.1.18 Consider the following recursive function:

    public static int mystery(int a, int b)
    {
        if (b == 0) return 0;
        if(b % 2 == 0) return mystery(a+a, b/2);
        return mystery(a+a, b/2) + a;
    }

What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what 
value mystery(a, b) computes. answer the same question, but replace + with * and replace return 0 with return 1.

mystery(2, 25) 
   1)     -> mystery(4, 12) + 2
   2)     -> ( mystery(8, 6) ) + 2
   3)     -> ( mystery(16, 3) + 16) + 2
   4)     -> (( mystery(32, 1) + 32 ) + 16) + 2
   5)     -> ( mystery(64, 0) + 32 ) + 16) + 2
   6)     -> ( 0 ) + 32 + 16 + 2
   = 50

   1) -> mystery(3, 11)
   2) -> ( mystery(6, 5) + 3
   3) -> ( mystery(12, 2) + 6) + 3
   4) -> ( mystery(24, 1) + 6) + 3
   5) -> ( mystery(48, 0) + 24 ) + 6) + 3
   5) -> ( 0 + 24 + 6 + 3)
   = 33

   mystery(a, b) = ?

Well, I thought best thing to do is try some small numbers and run them and see what it looks like:

example input:
0,  5 =  0
1,  5 =  5
2,  5 = 10
2, 25 = 50

it looks like the answer is a * b.

Lets put in some values just to check that works.  Try even and odd combinations.  You could use code like 
this to test:

  if(args.length < 2)
    System.out.println("Must pass 2 integer arguments");
  else {
    System.out.println(mystery(Integer.parseInt(args[0]), Integer.parseInt(args[1])));
  }

It seems to work.  Hence mystery(a, b) = a * b

I didn't really get the next part.  Change + to * and 0 for 1.  I did that and couldn't understand any 
pattern in the result.


1.1.19 Run the following program on your computer:

public class fibonacci {

    public static long f(int n)
    {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return f(n-1) + f(n-2);
    }

  public static void main(String[] args) {
      for(int  n = 0; n<100; n++)
          StdOut.println(n + " " + f(n));
  }
}

This program takes a long..... long.... time.

Largest value of n?  About 55?

The question asks for a better implementation which saves computed values in an array.

OK looked this up.  Idea is memoization.  See here:  
http://en.wikipedia.org/wiki/Memoization

And here for Java code examples: 
http://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Fibonacci_Number_Program#Java

Essentially, the idea is to 'chache' values in an array.

Doing this very simply with fixed size array:

public class fib_memo {

    static long[] fib = new long[100];

    public static long f(int n)
    {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if(fib[n] == 0) {
	    fib[n] = f(n-1) + f(n-2);
        }
        return fib[n];
    }


  public static void main(String[] args) {
      for(int  n = 0; n<100; n++)      
	  StdOut.printf("fib[%4d] = %14d\n", n, f(n));
  }
}

To do more professionally, you would need to use a re-sizeable array and keep expanding the array as large n's 
were required.  But this simple implementation makes operation very quick.  You now do not even notice any 
delay in printing results.

One other issue is that even the 64 bit long overflows with large fib numbers.  Looks like from fib(93).  
So better to use Java's bigInteger type for big n.




If you read up on fibonacci and the golden ratio you will see that there is an algebraic method of 
calculating fibonacci.  It is an estmimation but it is accurate for integer values.

Formula can be found here:
http://www.mathsisfun.com/numbers/nature-golden-ratio-fibonacci.html

In java code:

public class fibonacci {

    public static long f(int n)
    {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return f(n-1) + f(n-2);
    }

    // phi = (1 + sqrt(5) / 2)
    public static double phi()
    {
        return (1 + Math.sqrt(5)) / 2.0;
    }

    public static long fib_alg(int  n) {
        return (long)Math.round(Math.pow(phi(), n)  / Math.sqrt(5.0) );
    }

  public static void main(String[] args) {
      for(int  n = 0; n<100; n++)
          StdOut.println(n + " " + fib_alg(n));
  }
}


1.1.20 Write a recursive static method that computes the value of ln(N!)

public class ex_1_1_20 {

    public static long fact(int n)
    {
        if (n < 2) return 1;
        return n * fact(n-1);
    }

  public static void main(String[] args) {
      for(int  n = 0; n<20; n++)
          StdOut.printf("ln(%d!) = %f\n", n, Math.log(fact(n)));
  }
}


1.1.21 Write a program that reads in lines from std input with each line 
containing a name and two integers and then use printf() to print a table 
with a column of the names, the integers, and the result of dividing the 
first by the second, accurate to three decimal places. You could use a 
program like this to tabulate batting averages for baseball players or grades for students.

public class ex_1_1_21 {

public static class Data
{
    public Data() {}
    public Data(double v1, double v2, String s1) { n1 = v1; n2 = v2; s = s1; } 
    public double n1; 
    public double n2;  
    public String s; 
};

  public static void main(String[] args) {
	int i = 0;
	int idx = 0;  // array index  
	double v1, v2;
	v1 = v2 = 0;
	String s;

	Data items[] = new Data[100];  //asumes no more than 100 items

      while(!StdIn.isEmpty()) {
          switch(i % 3) {
	    case 0: v1 = StdIn.readFloat(); break;
            case 1: v2 = StdIn.readInt();   break;
            case 2:  
                s =  StdIn.readString(); 
		items[idx++] = new Data(v1, v2, s);
               break;
          }
          ++i;
      }
      
      StdOut.println("Item\tNum1\tNum2\tdiv");
      for(int j = 0; j < idx; ++j) {
          StdOut.printf(  "%s\t%3.3f\t%3.3f\t%3.3f\n", 
               items[j].s, items[j].n1, items[j].n2, items[j].n1 / items[j].n2);
      }	
      StdOut.printf("%d items\n", idx);           
  }
}






